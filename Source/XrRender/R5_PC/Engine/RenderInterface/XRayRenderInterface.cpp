#include "pch.h"

#include "../../xrEngine/IGame_Persistent.h"
#include "../../xrEngine/XR_IOConsole.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

XRayRenderInterface GRenderInterface;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT XRayRenderInterface::shader_compile(LPCSTR name, DWORD const* pSrcData, UINT SrcDataLen, LPCSTR pFunctionName, LPCSTR pTarget, DWORD Flags, void*& result)
{
	return E_NOTIMPL;
}

LPCSTR XRayRenderInterface::getShaderPath()
{
#if 1
	return "r5\\";
#else
	return "r5\\xbox\\";
#endif
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IRender_Sector* XRayRenderInterface::getSector(int id)
{
	return m_Sectors[id];
}

IRenderVisual* XRayRenderInterface::getVisual(int id)
{
	return GetVisual(id);
}


IRender_Target* XRayRenderInterface::getTarget()
{
	return GRenderTarget;
}

void XRayRenderInterface::set_Transform(Fmatrix* M)
{
	m_LTransform = *M;
	Rdsgraph_Genderal.set_Transform(M);
}

void XRayRenderInterface::set_HUD(BOOL V)
{
	m_bHUD = V;
	Rdsgraph_Genderal.set_HUD(V);
}

BOOL XRayRenderInterface::get_HUD()
{
	return m_bHUD;
}

void XRayRenderInterface::set_Invisible(BOOL V)
{
	Rdsgraph_Genderal.set_Invisible(V);
}

void XRayRenderInterface::set_Object(IRenderable* O)
{
}

void XRayRenderInterface::add_Occluder(Fbox2& bb_screenspace)
{
	HOM.occlude(bb_screenspace);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V)
{
}

void XRayRenderInterface::add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V)
{
}

void XRayRenderInterface::clear_static_wallmarks()
{
}

void XRayRenderInterface::add_SkeletonWallmark(const Fmatrix* xf, IKinematics* obj, IWallMarkArray* pArray, const Fvector& start, const Fvector& dir, float size)
{

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static float a;
class  ObjectSpecific :public IRender_ObjectSpecific
{
public:
	enum mode
	{
		TRACE_LIGHTS = (1 << 0),
		TRACE_SUN = (1 << 1),
		TRACE_HEMI = (1 << 2),
		TRACE_ALL = (TRACE_LIGHTS | TRACE_SUN | TRACE_HEMI),
	};
public:
	virtual void force_mode(u32 mode) {}
	virtual float get_luminocity() { return 0; }
	virtual float get_luminocity_hemi() { return 0; }
	virtual float* get_luminocity_hemi_cube() { return &a; }

	virtual ~ObjectSpecific() {};
};
IRender_ObjectSpecific* XRayRenderInterface::ros_create(IRenderable* parent)
{
	return xr_new< ObjectSpecific>();
}

void XRayRenderInterface::ros_destroy(IRender_ObjectSpecific*&)
{
}
class RLight : public IRender_Light
{
public:
public:
	virtual void set_type(LT type) {}
	virtual void set_active(bool) {}
	virtual bool get_active() { return false; }
	virtual void set_shadow(bool) {}
	virtual void set_volumetric(bool) {}
	virtual void set_volumetric_quality(float) {}
	virtual void set_volumetric_intensity(float) {}
	virtual void set_volumetric_distance(float) {}
	virtual void set_indirect(bool) {};
	virtual void set_position(const Fvector& P) {}
	virtual void set_rotation(const Fvector& D, const Fvector& R) {}
	virtual void set_cone(float angle) {}
	virtual void set_range(float R) {}
	virtual void set_virtual_size(float R) {}
	virtual void set_texture(LPCSTR name) {}
	virtual void set_color(const Fcolor& C) {}
	virtual void set_color(float r, float g, float b) {}
	virtual void set_hud_mode(bool b) {}
	virtual bool get_hud_mode() {
		return false;
	}
	virtual ~RLight() {}
};
IRender_Light* XRayRenderInterface::light_create()
{
	return xr_new< RLight>();
}

IRender_Glow* XRayRenderInterface::glow_create()
{
	return xr_new< XRayGlow>();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IRenderVisual* XRayRenderInterface::model_CreateParticles(LPCSTR name)
{
	return nullptr;
	//return xr_new<XRayRenderVisual>();
}

IRenderVisual* XRayRenderInterface::model_Create(LPCSTR name, IReader* data)
{
	return GModelPool->Create(name, data);
}

IRenderVisual* XRayRenderInterface::model_CreateChild(LPCSTR name, IReader* data)
{
	return  GModelPool->CreateChild(name, data);
}

IRenderVisual* XRayRenderInterface::model_Duplicate(IRenderVisual* V)
{
	return GModelPool->Instance_Duplicate((XRayRenderVisual*)V);
}

void XRayRenderInterface::model_Delete(IRenderVisual*& V, BOOL bDiscard)
{
	XRayRenderVisual* pVisual = (XRayRenderVisual*)V;
	GModelPool->Delete(pVisual, bDiscard);
	V = 0;
}

void XRayRenderInterface::model_Logging(BOOL bEnable)
{
	GModelPool->Logging(bEnable);
}

void XRayRenderInterface::models_Prefetch()
{
	GModelPool->Prefetch();
}

void XRayRenderInterface::models_Clear(BOOL b_complete)
{
	GModelPool->ClearPool(b_complete);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL XRayRenderInterface::occ_visible(vis_data& P)
{
	return HOM.visible(P);
}

BOOL XRayRenderInterface::occ_visible(Fbox& P)
{
	return HOM.visible(P);
}

BOOL XRayRenderInterface::occ_visible(sPoly& P)
{
	return HOM.visible(P);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::Flush()
{
	m_LTransform = Fidentity;
	GUniformAllocator->Flush();
	GRenderFastAllocator->FlushStart();
	Rdsgraph_Genderal.Flush();
	GRenderFastAllocator->FlushEnd();
	GRenderTarget->Flush();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::Screenshot(ScreenshotMode mode, LPCSTR name)
{
}

void XRayRenderInterface::Screenshot(ScreenshotMode mode, CMemoryWriter& memory_writer)
{
}

void XRayRenderInterface::ScreenshotAsyncBegin()
{
}

void XRayRenderInterface::ScreenshotAsyncEnd(CMemoryWriter& memory_writer)
{
}
void XRayRenderInterface::ScreenshotImpl(ScreenshotMode mode, LPCSTR name, CMemoryWriter* memory_writer)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::rmNear()
{
	HW->Context->SetViewport(0, 0, static_cast<float>(GRenderTarget->get_width()), static_cast<float>(GRenderTarget->get_height()), 0, 0.02f);
}

void XRayRenderInterface::rmFar()
{
	HW->Context->SetViewport(0, 0, static_cast<float>(GRenderTarget->get_width()), static_cast<float>(GRenderTarget->get_height()), 0.99999f, 1.f);
}

void XRayRenderInterface::rmNormal()
{
	HW->Context->SetViewport(0, 0, static_cast<float>(GRenderTarget->get_width()), static_cast<float>(GRenderTarget->get_height()), 0, 1.f);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

u32 XRayRenderInterface::memory_usage()
{
	return u32();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::BeforeWorldRender()
{
}

void XRayRenderInterface::AfterWorldRender()
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::ChangeMark(LPCSTR mark)
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

u32 XRayRenderInterface::active_phase()
{
	return u32();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::OnFrame()
{
	Device.seqParallel.insert(Device.seqParallel.begin(), fastdelegate::FastDelegate0<>(&HOM, &CHOM::MT_RENDER));
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



XRayRenderInterface::XRayRenderInterface()
{
	GRenderTarget = 0;
	GModelPool = 0;
	m_MWorld = Fidentity;
}



bool XRayRenderInterface::is_sun_static()
{
	return true;
}

DWORD XRayRenderInterface::get_dx_level()
{
	return 120;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::create()
{
	GRenderFastAllocator = xr_new<XRayRenderFastAllocator>();
	Device.seqFrame.Add(this, REG_PRIORITY_HIGH + 0x12345678);
	m_bHUD = FALSE;
	m_ScreenTransformation = BearRenderInterface::CreateUniformBuffer(sizeof(float) * 4, 1, true);
	{
		_vector4<float> ScreenTransformation;
		ScreenTransformation.set(static_cast<float>(Device.dwWidth), static_cast<float>(Device.dwHeight), 1.f / static_cast<float>(Device.dwWidth), 1.f / static_cast<float>(Device.dwHeight));
		memcpy(m_ScreenTransformation->Lock(), &ScreenTransformation, sizeof(float) * 4);
		m_ScreenTransformation->Unlock();
	}
	m_BloomScreenTransformation = BearRenderInterface::CreateUniformBuffer(sizeof(float) * 4, 1, true);
	{
		_vector4<float> ScreenTransformation;
		ScreenTransformation.set(static_cast<float>(RT_BLOOM_SIZE_X), static_cast<float>(RT_BLOOM_SIZE_Y), 1.f / static_cast<float>(RT_BLOOM_SIZE_X), 1.f / static_cast<float>(RT_BLOOM_SIZE_Y));
		memcpy(m_BloomScreenTransformation->Lock(), &ScreenTransformation, sizeof(float) * 4);
		m_BloomScreenTransformation->Unlock();
	}
	GRenderTarget = xr_new<XRayRenderTarget>();
	GModelPool = xr_new<XRayModelPool>();
	GUniformAllocator = xr_new<XRayUniformAllocator>();
	GTextureDescrManager = xr_new<XRayTextureDescrManager>();
	GTextureDescrManager->Load();
	

	//HW->ContextSky->AttachFrameBuffer(GRenderTarget->FrameBuffer_Sky);
}

void XRayRenderInterface::destroy()
{
	GTextureDescrManager->UnLoad();
	xr_delete(GTextureDescrManager);
	xr_delete(GUniformAllocator); GUniformAllocator = 0;
	xr_delete(GModelPool); GModelPool = 0;
	xr_delete(GRenderTarget); GRenderTarget = 0;
	m_ScreenTransformation.clear();
	m_BloomScreenTransformation.clear();
	Device.seqFrame.Remove(this);

	xr_delete(GRenderFastAllocator);
}

void XRayRenderInterface::reset_begin()
{
	xr_delete(GRenderTarget);
}

void XRayRenderInterface::reset_end()
{
	GRenderTarget = xr_new<XRayRenderTarget>();
	GRenderTarget->CompileShader();
	{
		_vector4<float> ScreenTransformation;
		ScreenTransformation.set(static_cast<float>(Device.dwWidth), static_cast<float>(Device.dwHeight), 1.f / static_cast<float>(Device.dwWidth), 1.f / static_cast<float>(Device.dwHeight));
		memcpy(m_ScreenTransformation->Lock(), &ScreenTransformation, sizeof(float) * 4);
		m_ScreenTransformation->Unlock();
	}
	{
		_vector4<float> ScreenTransformation;
		ScreenTransformation.set(static_cast<float>(RT_BLOOM_SIZE_X), static_cast<float>(RT_BLOOM_SIZE_Y), 1.f / static_cast<float>(RT_BLOOM_SIZE_X), 1.f / static_cast<float>(RT_BLOOM_SIZE_Y));
		memcpy(m_BloomScreenTransformation->Lock(), &ScreenTransformation, sizeof(float) * 4);
		m_BloomScreenTransformation->Unlock();

	}
	
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void XRayRenderInterface::UpdateDescriptorHeap(XRayShaderElement& ShaderElement, bool update_textures )
{
	if (ShaderElement.RootSignature.empty())return;
	if (ShaderElement.DescriptorHeap.empty())
	{
		ShaderElement.CreateDescriptorHeap();


		switch (ShaderElement.TypeTransformation)
		{
		case STT_BloomScreen:
			ShaderElement.DescriptorHeap->SetUniformBuffer(0, m_BloomScreenTransformation);
			break;
		case STT_Screen:
			ShaderElement.DescriptorHeap->SetUniformBuffer(0, m_ScreenTransformation);
			break;
		case STT_Matrix:
		{
			break;
		}
		break;
		default:
			break;
		}
		for (size_t i = 0; i < 16; i++)
		{
			if (ShaderElement.Textures[i])
			{
				ShaderElement.Textures[i]->Update();
				ShaderElement.DescriptorHeap->SetShaderResource(i, ShaderElement.Textures[i]->Texture);
			}
		}
	}
	else
	{
		for (size_t i = 0; i < 16; i++)
		{
			if (ShaderElement.Textures[i])
			{
				if (ShaderElement.Textures[i]->Update()|| update_textures)
				{
					ShaderElement.DescriptorHeap->SetShaderResource(i, ShaderElement.Textures[i]->Texture);
				}
			}
		}
	}
}

void XRayRenderInterface::SetView(const Fmatrix& mat)
{
	m_MView = mat;
}

void XRayRenderInterface::SetProject(const Fmatrix& mat)
{
	m_MProject = mat;
}

void XRayRenderInterface::SetWorld(const Fmatrix& mat)
{
	m_MWorld = mat;
}

void XRayRenderInterface::flush()
{
	R_ASSERT(0);
}
